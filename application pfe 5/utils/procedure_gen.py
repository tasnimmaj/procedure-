import os
import json
from pathlib import Path
import time
from langchain_groq import ChatGroq
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from langchain.schema import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import Chroma

# --- Configuration ---
DATA_PATH = "data/donnees.json"
VS_DIR = "data/chroma_store"

# Param√®tres optimis√©s
SIMILARITY_THRESHOLD = 0.2
MAX_NOTE_LENGTH = 500
MAX_EXAMPLES = 2
MIN_PROCEDURE_ROWS = 4
MAX_PROCEDURE_ROWS = 65

# --- Mod√®les disponibles ---
MODELS = {
    "mistral-saba-24b": {
        "name": "Mistral Saba 24B",
        "description": "Mod√®le √©quilibr√© pour une g√©n√©ration de qualit√© avec un bon rapport pr√©cision/vitesse",
        "provider": "Groq",
        "temperature": 0.3,
        "max_tokens": 4096
    },
    "llama-3.3-70b-versatile": {
        "name": "LLama 3.3 70B Versatile",
        "description": "Mod√®le de grande taille avec des capacit√©s avanc√©es de raisonnement et d'analyse",
        "provider": "Groq",
        "temperature": 0.25,
        "max_tokens": 4096
    },
    "qwen-qwq-32b": {
        "name": "Qwen QWQ 32B",
        "description": "Mod√®le performant avec une bonne compr√©hension contextuelle",
        "provider": "Groq",
        "temperature": 0.35,
        "max_tokens": 4096
    }
}

def get_api_key():
    """R√©cup√®re la cl√© API depuis les variables d'environnement"""
    api_key = os.getenv("GROQ_API_KEY")
    if not api_key:
        print("‚ùå ERREUR: Cl√© API non trouv√©e!")
        print("üîß SOLUTION:")
        print("   Windows: set GROQ_API_KEY=votre_cl√©_api")
        print("   Linux/Mac: export GROQ_API_KEY=\"votre_cl√©_api\"")
        print("\nüìã Puis red√©marrez votre script.")
        raise ValueError("Cl√© API GROQ_API_KEY manquante dans les variables d'environnement")
    return api_key

def init_llm(model_id="mistral-saba-24b", api_key=None):
    """Initialise le mod√®le LLM avec les param√®tres appropri√©s"""
    try:
        if not api_key:
            api_key = get_api_key()
            
        model_config = MODELS.get(model_id, MODELS["mistral-saba-24b"])
        
        llm = ChatGroq(
            groq_api_key=api_key,
            model_name=model_id,
            temperature=model_config["temperature"],
            max_tokens=model_config["max_tokens"]
        )
        
        print(f"‚úÖ LLM initialis√©: {model_config['name']}")
        return llm
    except Exception as e:
        raise Exception(f"‚ùå Erreur lors de l'initialisation du LLM: {e}")

def load_data(json_path=DATA_PATH):
    """Charge les donn√©es depuis le fichier JSON avec la structure attendue"""
    try:
        path = Path(json_path)
        if path.exists():
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            dossiers = data.get('dossiers', []) if isinstance(data, dict) else data
            
            docs = []
            notes_map = {}
            procedures_map = {}
            
            for dossier in dossiers:
                num = dossier.get('numero')
                nom = dossier.get('nom', '')
                
                note = dossier.get('note_circulaire', {})
                texte = note.get('texte', '') if isinstance(note, dict) else ''
                
                if texte:
                    docs.append(Document(
                        page_content=texte,
                        metadata={'numero': num, 'nom': nom}
                    ))
                    
                    notes_map[num] = texte
                    procedures_map[num] = dossier.get('procedures', [])
            
            print(f"üìä Donn√©es charg√©es: {len(docs)} documents")
            return {"docs": docs, "notes_map": notes_map, "procedures_map": procedures_map}
        
        print("‚ö†Ô∏è Fichier de donn√©es non trouv√©, cr√©ation d'une structure vide")
        return {"docs": [], "notes_map": {}, "procedures_map": {}}
    except Exception as e:
        print(f"‚ùå Erreur lors du chargement des donn√©es: {e}")
        return {"docs": [], "notes_map": {}, "procedures_map": {}}

def save_data(data, json_path=DATA_PATH):
    """Sauvegarde les donn√©es dans le fichier JSON"""
    try:
        path = Path(json_path)
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
        print(f"‚úÖ Donn√©es sauvegard√©es dans {json_path}")
        return True
    except Exception as e:
        print(f"‚ùå Erreur lors de la sauvegarde des donn√©es: {e}")
        return False

def init_vector_store(documents=None):
    """Initialise ou charge la base vectorielle"""
    try:
        embedder = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
        
        if documents and len(documents) > 0:
            import shutil
            if os.path.exists(VS_DIR):
                shutil.rmtree(VS_DIR, ignore_errors=True)
            
            Path(VS_DIR).mkdir(parents=True, exist_ok=True)
            splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
            chunks = splitter.split_documents(documents)
            vs = Chroma(collection_name='notes', persist_directory=VS_DIR, embedding_function=embedder)
            vs.add_documents(chunks)
            vs.persist()
            print(f"üóÑÔ∏è Base vectorielle cr√©√©e avec {len(chunks)} chunks")
            return vs
        
        if Path(VS_DIR).exists() and os.listdir(VS_DIR):
            try:
                vs = Chroma(collection_name='notes', persist_directory=VS_DIR, embedding_function=embedder)
                print(f"üóÑÔ∏è Base vectorielle charg√©e depuis {VS_DIR}")
                return vs
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur lors du chargement de la base vectorielle: {e}")
                import shutil
                shutil.rmtree(VS_DIR, ignore_errors=True)
        
        Path(VS_DIR).mkdir(parents=True, exist_ok=True)
        vs = Chroma(collection_name='notes', persist_directory=VS_DIR, embedding_function=embedder)
        vs.persist()
        print("üóÑÔ∏è Base vectorielle vide cr√©√©e")
        return vs
    except Exception as e:
        print(f"‚ùå Erreur lors de l'initialisation de la base vectorielle: {e}")
        return None

def find_similar_notes(vectorstore, query, k=MAX_EXAMPLES):
    """Recherche les notes circulaires similaires √† la requ√™te"""
    if not vectorstore:
        print("‚ö†Ô∏è Base vectorielle non initialis√©e.")
        return []
        
    try:
        results = vectorstore.similarity_search_with_score(query, k=k*2)
        
        similar_notes = []
        for doc, score in results:
            note_id = doc.metadata.get('numero', '')
            note_title = doc.metadata.get('nom', 'Sans titre')
            similarity = 1.0 / (1.0 + score)
            
            if similarity >= 0.4:
                similar_notes.append({
                    'id': note_id,
                    'titre': note_title,
                    'score': similarity,
                    'content': doc.page_content[:300]
                })
        
        similar_notes = similar_notes[:1]
        print(f"üîç Notes similaires trouv√©es: {len(similar_notes)}")
        return similar_notes
    except Exception as e:
        print(f"‚ùå Erreur lors de la recherche de notes similaires: {e}")
        return []

def generate_procedure_from_note_analysis(llm, query, num_steps):
    """G√©n√®re une proc√©dure en analysant uniquement le contenu de la note circulaire"""
    
    template = """# MISSION CRITIQUE
Vous devez analyser cette note circulaire UNIQUEMENT et cr√©er une proc√©dure op√©rationnelle sp√©cifique.

# INTERDICTIONS ABSOLUES
- Ne jamais utiliser d'exemples g√©n√©riques
- Ne jamais copier des mod√®les existants
- Chaque √©tape DOIT d√©couler directement du contenu de la note

# M√âTHODE D'ANALYSE OBLIGATOIRE
1. Lisez ENTI√àREMENT la note circulaire ci-dessous
2. Identifiez l'OBJECTIF principal mentionn√© dans la note
3. Rep√©rez toutes les EXIGENCES sp√©cifiques √©num√©r√©es
4. Identifiez les CONTR√îLES requis
5. D√©terminez les ACTEURS impliqu√©s selon la note
6. Listez les DOCUMENTS mentionn√©s dans la note

# NOTE CIRCULAIRE √Ä ANALYSER
{query}

# ANALYSE PR√âALABLE OBLIGATOIRE
Avant de cr√©er les √©tapes, r√©pondez mentalement √† ces questions :
- Quel est le sujet principal de cette note ?
- Quelles sont les obligations sp√©cifiques mentionn√©es ?
- Qui doit faire quoi selon cette note ?
- Quels documents sont requis d'apr√®s la note ?
- Quelles v√©rifications sont demand√©es ?

# FORMAT DE SORTIE STRICT
| N¬∞ | Activit√©s | Description | Acteurs | Documents | Applications |
|---|---|---|---|---|---|
[EXACTEMENT {num_steps} √©tapes bas√©es sur l'analyse de la note]

# R√àGLES DE G√âN√âRATION
- Chaque √©tape = un √©l√©ment concret de la note commanceant par un verbe 
- Description de 35-80 mots expliquant le POURQUOI selon la note
- Acteurs = ceux mentionn√©s ou impliqu√©s par la note
- Documents = ceux cit√©s ou requis par la note
- Applications = syst√®mes logiques pour cette activit√©

# CONTRAINTES TECHNIQUES
- Remplacez "cr√©dit" par "Financement" si applicable
- Remplacez "leasing" par "Leasing (Ijara)" si applicable
- Soyez PR√âCIS et SP√âCIFIQUE √† cette note, pas g√©n√©rique

ANALYSEZ cette note circulaire et cr√©ez une proc√©dure UNIQUE qui lui correspond !"""

    prompt = PromptTemplate(
        input_variables=['query', 'num_steps'],
        template=template
    )
    
    chain = LLMChain(llm=llm, prompt=prompt)
    
    try:
        result = chain.run({
            'query': query,
            'num_steps': num_steps
        })
        return result    
    except Exception as e:
        raise Exception(f"‚ùå Erreur lors de la g√©n√©ration bas√©e sur l'analyse: {e}")

def generate_procedure_with_minimal_context(llm, query, similar_notes, num_steps):
    """G√©n√®re une proc√©dure avec un contexte minimal pour √©viter la copie"""
    
    domain_context = ""
    if similar_notes:
        note = similar_notes[0]
        content = note['content'][:200]
        
        if any(word in content.lower() for word in ['cr√©dit', 'financement', 'pr√™t']):
            domain_context = "Domaine identifi√©: Financement bancaire"
        elif any(word in content.lower() for word in ['conformit√©', 'r√©glementation']):
            domain_context = "Domaine identifi√©: Conformit√© r√©glementaire"
        elif any(word in content.lower() for word in ['pme', 'entreprise']):
            domain_context = "Domaine identifi√©: Services aux entreprises"
        else:
            domain_context = "Domaine identifi√©: Services bancaires g√©n√©raux"
    
    template = """# MISSION PRINCIPALE
Cr√©ez une proc√©dure ORIGINALE bas√©e UNIQUEMENT sur l'analyse de la note circulaire fournie.

# CONTEXTE MINIMAL (pour orientation g√©n√©rale seulement)
{domain_context}

# INTERDICTION ABSOLUE
- Ne copiez JAMAIS d'exemples existants
- Ne vous basez que sur le CONTENU de la note circulaire
- Chaque √©tape doit traiter un aspect SP√âCIFIQUE de la note

# NOTE CIRCULAIRE √Ä ANALYSER EN D√âTAIL
{query}

# PROCESSUS D'ANALYSE OBLIGATOIRE
1. Identifiez l'OBJET principal de cette note circulaire
2. Listez toutes les EXIGENCES mentionn√©es dans le texte
3. Identifiez les √âTAPES logiques pour appliquer ces exigences
4. D√©terminez les ACTEURS n√©cessaires pour chaque √©tape
5. Identifiez les DOCUMENTS requis selon la note

# FORMAT DE SORTIE ATTENDU
| N¬∞ | Activit√©s | Description | Acteurs | Documents | Applications |
|---|---|---|---|---|---|
[EXACTEMENT {num_steps} lignes bas√©es sur l'analyse de la note]

# CONTRAINTES DE QUALIT√â
- Descriptions de 40-85 mots expliquant le processus sp√©cifique
- Chaque √©tape doit correspondre √† un √©l√©ment de la note
- Soyez concret et op√©rationnel
- Adaptez "cr√©dit" en "Mourabaha" et "leasing" en "Leasing (Ijara)"

# INSTRUCTION FINALE
Analysez cette note circulaire et cr√©ez des √©tapes qui refl√®tent EXACTEMENT ses exigences !"""

    prompt = PromptTemplate(
        input_variables=['query', 'domain_context', 'num_steps'],
        template=template
    )
    
    chain = LLMChain(llm=llm, prompt=prompt)
    
    try:
        result = chain.run({
            'query': query,
            'domain_context': domain_context,
            'num_steps': num_steps
        })
        return result
    except Exception as e:
        raise Exception(f"‚ùå Erreur lors de la g√©n√©ration avec contexte minimal: {e}")

def generate_io_table_with_model(llm, query, num_io_rows=3):
    """G√©n√®re un tableau entr√©es/sorties bas√© sur l'analyse de la note circulaire"""
    
    template = """# MISSION
Analysez cette note circulaire et cr√©ez EXACTEMENT {num_rows} √©v√©nements d'entr√©es/sorties.

# NOTE CIRCULAIRE √Ä ANALYSER
{query}

# ANALYSE REQUISE
1. Identifiez le d√©clencheur principal de la note
2. Identifiez les processus internes n√©cessaires
3. Identifiez les sorties/r√©sultats attendus

# FORMAT DE SORTIE STRICT
| Ev√®nement | Processus en interface | Description du processus en interface |
| --- | --- | --- |
[EXACTEMENT {num_rows} lignes bas√©es sur l'analyse de la note]

# INSTRUCTIONS
- Premi√®re ligne : √©v√©nement d√©clencheur de la note
- Lignes interm√©diaires : processus de traitement identifi√©s
- Derni√®re ligne : r√©sultat/sortie final
- Descriptions d√©taill√©es de 25-60 mots
- Basez-vous UNIQUEMENT sur le contenu de la note circulaire

Analysez la note et cr√©ez les √©v√©nements correspondants !"""

    prompt = PromptTemplate(
        input_variables=['query', 'num_rows'],
        template=template
    )
    
    chain = LLMChain(llm=llm, prompt=prompt)
    
    try:
        result = chain.run({
            'query': query[:1000],
            'num_rows': num_io_rows
        })
        
        if "| Ev√®nement | Processus en interface | Description du processus en interface |" not in result:
            header = "| Ev√®nement | Processus en interface | Description du processus en interface |"
            separator = "| --- | --- | --- |"
            result = f"{header}\n{separator}\n{result.strip()}"
        
        return result.strip()
    except Exception as e:
        raise Exception(f"‚ùå Erreur lors de la g√©n√©ration du tableau I/O: {e}")

def generate_procedure_with_io(llm, query, similar_notes=None, notes_map=None, procedures_map=None, num_steps=None, num_io_rows=3):
    """G√©n√®re la proc√©dure ET le tableau I/O bas√©s sur l'analyse de la note"""
    
    procedure_result = generate_procedure(llm, query, similar_notes, notes_map, procedures_map, num_steps)
    io_table = generate_io_table_with_model(llm, query, num_io_rows)
    
    return {
        'procedure': procedure_result,
        'io_table': io_table
    }

def generate_procedure(llm, query, similar_notes=None, notes_map=None, procedures_map=None, num_steps=None):
    """G√©n√®re la proc√©dure avec focus sur l'analyse de la note circulaire"""
    
    if num_steps is not None:
        target_steps = num_steps
        print(f"üéØ G√©n√©ration avec exactement {num_steps} √©tapes demand√©es")
    else:
        target_steps = MIN_PROCEDURE_ROWS
        print("üéØ Utilisation du nombre d'√©tapes par d√©faut")
    
    query_truncated = query[:1500] if len(query) > 1500 else query
    
    print(f"üìù G√©n√©ration de proc√©dure pour: {query_truncated[:100]}...")
    
    if not similar_notes or len(similar_notes) == 0:
        print("üîç G√©n√©ration bas√©e sur l'analyse pure de la note circulaire")
        return generate_procedure_from_note_analysis(llm, query_truncated, target_steps)
    
    print(f"üîç G√©n√©ration avec contexte minimal ({len(similar_notes)} note(s) pour orientation)")
    return generate_procedure_with_minimal_context(llm, query_truncated, similar_notes, target_steps)

def generate_procedure_with_model(query, model_id="mistral-saba-24b", api_key=None, vectorstore=None, notes_map=None, procedures_map=None, num_steps=None, num_io_rows=3):
    """G√©n√®re proc√©dure + tableau I/O bas√©s sur l'analyse de la note circulaire"""
    
    print("üöÄ D√©but de la g√©n√©ration bas√©e sur l'analyse de la note circulaire...")
    
    if not api_key:
        api_key = get_api_key()
    
    llm = init_llm(model_id, api_key)
    
    if vectorstore is not None and notes_map is not None and procedures_map is not None:
        print("üìä Param√®tres RAG fournis, recherche de contexte minimal...")
        similar_notes = find_similar_notes(vectorstore, query)
        if similar_notes:
            print(f"‚úÖ Contexte minimal trouv√©: {len(similar_notes)} note(s) pour orientation")
        else:
            print("‚ÑπÔ∏è Aucun contexte trouv√©, g√©n√©ration bas√©e uniquement sur la note")
        result = generate_procedure_with_io(llm, query, similar_notes, notes_map, procedures_map, num_steps, num_io_rows)
        return result
    
    print("üìÇ Chargement des donn√©es pour contexte minimal...")
    
    data = load_data()
    print(f"üìä Donn√©es charg√©es: {len(data['docs'])} documents disponibles")
    
    vectorstore = init_vector_store(data["docs"])
    
    if vectorstore is None:
        print("‚ö†Ô∏è Base vectorielle non disponible, g√©n√©ration bas√©e uniquement sur la note")
        result = generate_procedure_with_io(llm, query, num_steps=num_steps, num_io_rows=num_io_rows)
        return result
    
    similar_notes = find_similar_notes(vectorstore, query)
    
    if similar_notes:
        print(f"‚úÖ Contexte minimal identifi√©: {len(similar_notes)} note(s) pour orientation g√©n√©rale")
    else:
        print("‚ÑπÔ∏è Aucun contexte similaire, g√©n√©ration bas√©e uniquement sur l'analyse de la note")
    
    result = generate_procedure_with_io(
        llm=llm,
        query=query,
        similar_notes=similar_notes,
        notes_map=data["notes_map"],
        procedures_map=data["procedures_map"],
        num_steps=num_steps,
        num_io_rows=num_io_rows
    )
    
    return result

def main_generate_procedure(query, model_id="mistral-saba-24b", api_key=None, num_steps=None, num_io_rows=3):
    """Point d'entr√©e principal pour la g√©n√©ration de proc√©dures"""
    result = generate_procedure_with_model(
        query=query,
        model_id=model_id,
        api_key=api_key,
        num_steps=num_steps,
        num_io_rows=num_io_rows
    )
    
    return result

def extract_procedure_components(procedure_text):
    """Extrait le tableau des √©tapes, le tableau I/O et les sc√©narios de la proc√©dure"""
    if not procedure_text:
        return {"etapes": "", "io": "", "scenarios": "", "scenarios_ok": "", "scenarios_ko": ""}
    
    # Initialiser les composants
    components = {
        "etapes": "",
        "io": "",
        "scenarios": "",
        "scenarios_ok": "",
        "scenarios_ko": ""
    }
    
    # Extraire les sections par analyse ligne par ligne
    current_section = []
    current_section_type = None
    
    lines = procedure_text.split("\n")
    i = 0
    
    while i < len(lines):
        line = lines[i].strip()
        
        # D√©tecter le d√©but du tableau des √©tapes - AM√âLIORATION
        if (("| N¬∞" in line or "| No." in line or "| Num√©ro" in line or "| √âtape" in line) and 
            ("Description" in line or "Activit√©s" in line)) or \
           ("| Activit√©s |" in line and "| Description |" in line):
            if current_section_type and current_section:
                components[current_section_type] = "\n".join(current_section)
            
            current_section = [line]
            current_section_type = "etapes"
            i += 1
            continue
            
        # D√©tecter le d√©but du tableau I/O
        if "| Ev√®nement | Processus en interface | Description du processus en interface |" in line or \
           "| √âv√©nement | Processus en interface | Description du processus en interface |" in line:
            if current_section_type and current_section:
                components[current_section_type] = "\n".join(current_section)
            
            current_section = [line]
            current_section_type = "io"
            
            # S'assurer que nous avons la ligne de s√©paration
            if i + 1 < len(lines) and "| ---" in lines[i + 1]:
                current_section.append(lines[i + 1])
                i += 2
            else:
                current_section.append("| --- | --- | --- |")
                i += 1
            continue
            
        # D√©tecter le d√©but des sc√©narios g√©n√©raux
        if ("# Sc√©narios" in line or "## Sc√©narios" in line) and not "OK" in line and not "KO" in line and not "r√©ussi" in line.lower() and not "√©chec" in line.lower():
            if current_section_type and current_section:
                components[current_section_type] = "\n".join(current_section)
            
            current_section = [line]
            current_section_type = "scenarios"
            i += 1
            continue
            
        # D√©tecter les sc√©narios OK/r√©ussis
        if ("# Sc√©narios OK" in line or "## Sc√©narios OK" in line or 
            "# Sc√©narios r√©ussis" in line or "## Sc√©narios r√©ussis" in line or
            "# Sc√©nario de r√©ussite" in line or "## Sc√©nario de r√©ussite" in line):
            if current_section_type and current_section:
                components[current_section_type] = "\n".join(current_section)
            
            current_section = [line]
            current_section_type = "scenarios_ok"
            i += 1
            continue
            
        # D√©tecter les sc√©narios KO/√©chec
        if ("# Sc√©narios KO" in line or "## Sc√©narios KO" in line or 
            "# Sc√©narios d'√©chec" in line or "## Sc√©narios d'√©chec" in line or
            "# Sc√©nario d'√©chec" in line or "## Sc√©nario d'√©chec" in line):
            if current_section_type and current_section:
                components[current_section_type] = "\n".join(current_section)
            
            current_section = [line]
            current_section_type = "scenarios_ko"
            i += 1
            continue
            
        # Si on est dans une section identifi√©e, ajouter la ligne
        if current_section_type:
            current_section.append(line)
            
        i += 1
    
    # Sauvegarder la derni√®re section
    if current_section_type and current_section:
        components[current_section_type] = "\n".join(current_section)
    
    # NOUVELLE FONCTION : Extraire le vrai d√©but et fin des √©tapes
    def get_real_start_end_steps(etapes_text):
        if not etapes_text:
            return None, None
            
        lines = etapes_text.split("\n")
        steps = []
        
        for line in lines:
            line = line.strip()
            if line.startswith("|") and line.endswith("|") and "---" not in line:
                # Extraire le contenu de la ligne du tableau
                cells = [cell.strip() for cell in line.split("|")[1:-1]]  # Enlever les | du d√©but/fin
                if len(cells) >= 2 and cells[0] and cells[1]:  # Au moins num√©ro et description
                    # Ignorer les en-t√™tes
                    if not any(header in cells[1].lower() for header in ['description', 'activit√©', '√©tape']):
                        steps.append(cells[1])  # Prendre la description de l'√©tape
        
        if steps:
            return steps[0], steps[-1]  # Premier et dernier step r√©els
        return None, None
    
    # Nettoyer et formater le tableau I/O
    if components["io"]:
        lines = components["io"].split("\n")
        if len(lines) >= 1:
            # En-t√™te standardis√©
            header = "| Ev√®nement | Processus en interface | Description du processus en interface |"
            separator = "| --- | --- | --- |"
            data_lines = []
            
            # Extraire uniquement les lignes de donn√©es
            data_started = False
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                if "| ---" in line:
                    data_started = True
                    continue
                if data_started and line.startswith("|") and line.endswith("|"):
                    data_lines.append(line)
                elif not data_started and line.startswith("|") and line.endswith("|") and "Ev√®nement" not in line and "√âv√©nement" not in line:
                    data_lines.append(line)
                    
            # Reconstruire le tableau avec un format propre
            if data_lines:
                components["io"] = "\n".join([header, separator] + data_lines)
            else:
                # Garder le contenu original si on n'arrive pas √† extraire les donn√©es
                components["io"] = "\n".join(lines)
    
    # Nettoyer le tableau des √©tapes ET extraire d√©but/fin r√©els
    if components["etapes"]:
        lines = components["etapes"].split("\n")
        cleaned_lines = []
        for line in lines:
            line = line.strip()
            if line:
                cleaned_lines.append(line)
        components["etapes"] = "\n".join(cleaned_lines)
        
        # AJOUT : Extraire les vrais points de d√©but et fin
        start_step, end_step = get_real_start_end_steps(components["etapes"])
        components["real_start"] = start_step
        components["real_end"] = end_step
    
    # Nettoyer les sections de sc√©narios
    for scenario_type in ["scenarios", "scenarios_ok", "scenarios_ko"]:
        if components[scenario_type]:
            lines = components[scenario_type].split("\n")
            cleaned_lines = []
            for line in lines:
                line = line.strip()
                if line:
                    cleaned_lines.append(line)
            components[scenario_type] = "\n".join(cleaned_lines)
    
    return components

def test_generation_function(api_key=None):
    """Fonction de test pour v√©rifier le bon fonctionnement"""
    if not api_key:
        api_key = get_api_key()
    
    test_query = "Note circulaire concernant les proc√©dures de cr√©dit aux PME"
    
    result = main_generate_procedure(
        query=test_query,
        api_key=api_key,
        num_steps=5,
        num_io_rows=3
    )
    
    print("‚úÖ Test r√©ussi!")
    print(f"üìÑ Proc√©dure g√©n√©r√©e: {len(result['procedure'])} caract√®res")
    print(f"üìä Tableau I/O g√©n√©r√©: {len(result['io_table'])} caract√®res")
    
    return result

# === SECTION DE TEST ===
def main():
    """Fonction principale pour tester le g√©n√©rateur"""
    print("üèÅ === G√âN√âRATEUR DE PROC√âDURES BANCAIRES ===")
    print("üîë V√©rification de la cl√© API...")
    
    try:
        # Test avec la cl√© API depuis les variables d'environnement
        api_key = get_api_key()
        print(f"‚úÖ Cl√© API trouv√©e: {api_key[:10]}...")
        
        # Test de g√©n√©ration
        print("\nüß™ Test de g√©n√©ration...")
        test_query = """
        Note circulaire N¬∞2024-001 concernant les nouvelles proc√©dures d'octroi de cr√©dit aux PME.
        
        Cette note d√©finit les modalit√©s de traitement des demandes de financement pour les petites et moyennes entreprises.
        
        Les √©tapes √† suivre sont:
        1. R√©ception et enregistrement de la demande
        2. V√©rification des documents requis
        3. Analyse de la capacit√© de remboursement
        4. √âvaluation des garanties
        5. D√©cision d'octroi
        
        Documents requis: Bilan comptable, relev√©s bancaires, business plan, garanties.
        """
        
        result = main_generate_procedure(
            query=test_query,
            model_id="mistral-saba-24b",
            api_key=api_key,
            num_steps=6,
            num_io_rows=3
        )
        
        print("\n" + "="*60)
        print("üìã PROC√âDURE G√âN√âR√âE:")
        print("="*60)
        print(result['procedure'])
        
        print("\n" + "="*60)
        print("üìä TABLEAU ENTR√âES/SORTIES:")
        print("="*60)
        print(result['io_table'])
        
        print("\n‚úÖ G√âN√âRATION R√âUSSIE!")
        
    except Exception as e:
        print(f"‚ùå ERREUR: {e}")
        print("\nüîß V√âRIFIEZ:")
        print("1. Que votre variable d'environnement GROQ_API_KEY est d√©finie")
        print("2. Que votre cl√© API est valide")
        print("3. Que vous avez une connexion internet")

if __name__ == "__main__":
    main()